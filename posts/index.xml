<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Panos Karabelas</title>
		<link>https://panoskarabelas.com/posts/</link>
		<description>Recent content in Posts on Panos Karabelas</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sun, 28 Jun 2020 00:00:00 +0000</lastBuildDate>
		<atom:link href="https://panoskarabelas.com/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Screen space shadows</title>
			<link>https://panoskarabelas.com/posts/screen_space_shadows/</link>
			<pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate>
			
			<guid>https://panoskarabelas.com/posts/screen_space_shadows/</guid>
			<description>Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
float ScreenSpaceShadows(Surface surface, Light light){// Compute rayfloat3 ray_pos = mul(float4(surface.</description>
			<content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&rsquo;t cover using CSS to style your theme.</p>
<pre><code>float ScreenSpaceShadows(Surface surface, Light light)
{
    // Compute ray
    float3 ray_pos      = mul(float4(surface.position, 1.0f), g_view).xyz;
    float3 ray_dir      = mul(float4(-light.direction, 0.0f), g_view).xyz;
    float step_length   = g_sss_ray_max_distance / (float)g_sss_steps;
    float3 ray_step     = ray_dir * step_length;
    float2 ray_uv       = 0.0f;
    float shadow        = 1.0f;

    // Offseting with some temporal interleaved gradient noise, will capture more detail
    float offset = interleaved_gradient_noise(g_resolution * surface.uv);
    ray_pos += ray_step * offset;

    // Ray march towards the light
    float occlusion = 0.0;
    for (uint i = 0; i &lt; g_sss_steps; i++)
    {
        // Step ray
        ray_pos += ray_step;
        ray_uv  = project_uv(ray_pos, g_projection);

        [branch]
        if (is_saturated(ray_uv))
        {
            // Compare depth
            float depth_z       = get_linear_depth(ray_uv);
            float depth_delta   = ray_pos.z - depth_z;
    
            // Occlusion test
            if (abs(g_sss_tolerance - depth_delta) &lt; g_sss_tolerance)
            {
                occlusion = 1.0f;
                break;
            }
        }
    }

    // fade when out of screen
    occlusion *= screen_fade(ray_uv);
    
    return 1.0f - occlusion;
}
</code></pre>]]></content>
		</item>
		
	</channel>
</rss>
